Questions:

===================
MiscConstants:
We have turnaround times of 75 and 90 minutes on Casters 2 and 3.
And 0 on Caster 1.
What are values of turnaround time for Casters 4,5?

Answer: 
#4 (1CCM) 150 minutes  -- DONE
#5 (2CCM)  90 minutes  -- DONE

===================


Length CMiscConstants::m_casterSlabLengthMaxes[4] = { 0, 452, 452, 431 };
What are values for casters 4,5?

Answer: Slab Length Both Casters
 
Min 200” Max 460”   -- DONE

====================


PerUserDefaultValues:
Need values for
Caster4HeatSizeMin
Caster4HeatSizeAim
Caster4HeatSizeMax
Caster5HeatSizeMin
Caster5HeatSizeAim
Caster5HeatSizeMax

Answer: Heat size for both West casters
 
Min 255
Aim 265
Max 280

This is encoded in the database.  -- DONE on dev, needs to be done on test and in production.

===================


PPGHeatSizes:
There is an editing screen for the caster 1,2,3 heat size min/aim/max that I will add to.
On that dialog, the values for casters 2,3 are tied to be identical.
Is there any similar tying of values for 4 and 5?

Answer:  Tie together casters 4 and 5.
This is in the editing screen.
DONE.

========================


What are the formulas for calculating cast times on casters 4,5?

 Answer: During 3SP lineup handoff, Vino Lawrence can provide from PHD calculations
 Status: in process.


=========================

How are specs associated with casters?
Specs are in the following tables:

	HeatSpecCrossApp -- 
		maps specs to specs, caster not involved in the table.
		However, caster is involved in the lookup oi check certain characters in the spec:
		
				// filter for specs suitable for this caster
			  
				if ( dig4 == '0'
					 ||
					 ( caster == 1 && ( dig4 == '4' || dig4 == '7' ) )
					 ||
					 ( caster != 1 && ( dig4 == '2' ) ) )			
		
		Question: Is this correct for casters 4,5?

		Interpretation: I take this to mean that this code need no modification.
		Status: DONE


===============================
		
	SteelSpecCrossAppSet
		caster not involved
		Status: nothing to do, so DONE.

===============================
		
	SpecChemRangePreset
		caster not involved
		Status: nothing to do, so DONE.

==============================
		
	SpecDPAChemsSet
	SpecDPASet
		Both have a field CString	m_CASTER_INDICATOR;
			m_forCaster[1] = (dpaSpec.m_CASTER_INDICATOR.Find('1') != -1);
			m_forCaster[2] = (dpaSpec.m_CASTER_INDICATOR.Find('2') != -1);
			m_forCaster[3] = (dpaSpec.m_CASTER_INDICATOR.Find('3') != -1);
			m_isBloomSpec  = (dpaSpec.m_CASTER_INDICATOR.Find('B') != -1);
			
		Will the same be true for Casters 4,5?	
		
		Answer:  Skip this for casters 4 and 5, do nothing here.

>>>>>		Asking again, a different way:  How do I know if a spec is for caster 4 or 5?

============================

	In CSpecMgr::FindSpecMaybe
		When looking up spec info given the spec name, we first look it up directly.
		If not found, we plae with the first digit of the second group:
			//  XXX-0X-XX ==>  XXX-2X-XX    if caster == 2 or 3
			//  XXX-0X-XX ==>  XXX-4X-XX     if caster == 1
			//  XXX-0X-XX ==>  XXX-7X-XX     if caster == 1
		Do any of these transformations apply to casters 4,5?  Other transformations?

		Answer: Skip this for casters 4 and 5, do nothing here.
		Status: DONE

=============================
		
		At the moment, calls to FindSpecMaybe from CSpecMgr::InitializeDPAChems has a strange caster calculation:
		
				//at the moment, having only caster == 2 or not has the desired effect.
				int caster;
				if ( chemSet.m_CASTER_INDICATOR.Find('1') != -1 )
					caster = 1;
				else 
					caster = 2;

				CSpec* pSpec = FindSpecMaybe(spec,caster);
				
				This is true only because we care about caster 1 vs caster 2.  We are checking for "on 1" vs "not on 1" because this triggers code in FindSpecMaybe.
				What do we do with the new casters?

		Answer: In this body of logic, let’s ensure casters 4 and 5 are omitted from all (chemSet.m_CASTER_INDICATOR) reactions, decisions, or results. 
		The CASTER_INDICATOR field will not be used, or populated at this time, for casters 4 and 5.

>>>>>		Asking again, a different way:  How do I know if a spec is for caster 4 or 5?

============================

Orders:

	We determine which caster an order is for by looking at table unappliedorders, fields
			SM_PLAN_SLAB_UNIT_CD
			SM_PLAN_FACL_PREF_1_CD
			SM_PLAN_FACL_PREF_2_CD
			SM_PLAN_FACL_PREF_3_CD
	These will contain values "4" and "5"  (they are strings) to indicate orders for those casters?
	
	ANSWER:   No. For casters 4, and 5 SM_PLAN_FACL_PREF_1_CD = “O” (this is the alpha letter O, not a numeric zero) 

>>>>>>>>  Updated question:  How do I tell if an order is for 4 or 5 or both?

===============================


number of strands
		Caster  #strands
			1		2
			2		1
			3		2
			4		1  ???
			5		1  ???

	ANSWER:  This is correct.  Both are one strand.  
	STATUS:  Already coded this way, so DONE.

==========================


CCastStringValidator::Validate340080
			audit numPieces
			if ( caster == 1 ) {

				if ( numPieces == 0 
					 || 
					 (numPieces > 32 && numPieces != 99) ) {
					ostr << "#PC must be < 33"
						 << ends;
					ADD_ERR(CCastStringHeatValidnError::FATAL);
					isOk = false;
				}
			}

	Comment is: TRUE.
	I take this to mean that this test is Caster 1 only, so no need to change this code.
	STATUS: DONE

================================
			
			audit steel width
			if ( caster == 3 ) {

				if ( width < 24 || width > 60 ) {
					ostr << "steel width ("
						 << setw(2) << width
						 << ") not in range [24,60]"
						 << ends;
					ADD_ERR(CCastStringHeatValidnError::FATAL);
					isOk = false;
				}
			}

	ANSWER: Correct Ignore for casters 4, and 5 (3SP)
	STATUS: Nothing to do, so DONE.

===============================
			
			//  check heat position for 3 combi startup slabs

			{
				if ( caster == 3 ) {
			
	ANSWER: None today Ignore for casters 4 and 5 
	STATUS: Nothing to do, so DONE.

=================================
			
			// audit steel length compliance with steelshop limitations
			if ( caster == 1 ) {
			if ( caster == 2 ) {
			if ( caster == 3 ) {

	ANSWER:   None today Ignore for casters 4 and 5
	STATUS: nothing to do, so DONE.

=================================
			
			// audit exposure code
			if ( caster == 1 )
			else

	ANSWER: None today Ignore for casters 4 and 5
	ACTION:  Need to restrict ELSE clasue to only casters 2,3.

====================================

			
			// Audit 2BOF inward width change designs.  1-28-10 k. hubbard
			{
				if (( caster == 2 || caster == 3)
		
	
			
			Any such checks for 4, 5?
			Answer: Ignore for casters 4 and 5 today. In the future some grades will be inward only, but not today.
			Status: nothing to do, so DONE.

=====================================
			
		CCastStringValidator::FixHeatSpec
			Special rules for casters 2 3
			Anything for 4,5

			Answer: None today Ignore for casters 4 and 5

			Re-ask:  Should have been more careful here.  This is one case for casters 2,3.
			There is an else clause.  SHould this else clause apply only to caster 1?

			else {
		
				CString front = heatSpec.Left(5);
				if ( front == "52440" || front == "52442" || front == "52449" ) {
					// do nothing.     Added 52442xx spec above, to the exception list of fourth digit modifications. maint. 5/30/06 k. hubbard
				} else {
					if ( ord4 == '7' || ord4 == '4' || ord4 == '6' )
						heatSpec.SetAt(3,ord4);
					else
						heatSpec.SetAt(3,'7');
	
					if ( ord4 == '4' )
						heatSpec.SetAt(5,'4');
				}

======================================

		CCastString::PourToOpenTime
			What is correct calculation of PourToOpenTime for casters 4,5?

		Answer: Unknown, KHH will follow up.
		Status: PENDING

======================================

		CCastString::HotMetalTonsPerHeat()	
			What is value for HotMetalTonsPerHeat for casters 4,5?

		Answer: 217 tons per heat
		Status: DONE

======================================

		CCastStringHeat::FixAimChem
				//  Fix aim chem for a given element 
				//    given the range object from the spec for that element.
				//
				//  The aim chem will have already been set from the range element.
				//  That value may need adjusting.  Specifically, 
				//     case 1) if on casters 2 or 3, 
				//             and the element is Sulfur.
				//             and min is 0 and max is non-trivial (not 0, not 100)
				//			   and aim is 0
				//     case 2) not ( on casters 2,3, element Sulfur)
				//             and min > 0 and max is non-trivial
				//			   and aim is 0
				//
				//  in case 1), aim = max - 0.001
				//  in case 2), aim = average(min,max)
			WHat is correct calculation for casters 4,5?

			Answer: None today Ignore for casters 4 and 5
			Status: Needed some code to restrict default case.  DONE

=====================================
			
		CCastStringIdDlg::SetWidthSpinLimits
				We have values for 1 and not 1.  What about 4,5?

				Answer: Casters 4 max = 80” and 5 max = 84”

				Ask also:  what are min values?

				Status: Maxes done, need min values

======================================
			
		CTabNumDlg::InitTabNum
			m_force2ndDigit = m_caster != 1;  <- do we force second digit on tab# for casters 4,5
		
			if ( m_caster == 3 )
				str = "3";
			else if ( m_caster == 2 )
				str = "2";
			else str = "4";
			
			if ( m_force2ndDigit )
				str += "9";			
			
			What is starting digit for tab#s for casters 4,5?

			Answers:	Yes, force caster 4 digit 2 = 1, and caster 5 digit 2 = 2.
						Starting digit for caster 4 is 1. Starting digit for caster 5 is 5.
			Status: DONE

====================================
			
		 CTabNumDlg::ValidateTabNum
			What are valid tab#s for casters 4,5?
			
				if ( ! (firstDigit == '9' 
						||
						(m_caster == 1  && firstDigit != 2 && firstDigit != 3)
						||
						firstDigit == '2' && m_caster == 2 
						||
						firstDigit == '3' && m_caster == 3 ) ) {
				
					MessageBox("First digit invalid for caster.",
							   "Bad TAB #",
								MB_ICONHAND | MB_OK);			


				//	if ( m_force2ndDigit && str[1] != '9' ) {
				//		MessageBox("Second digit must be 9 (for slabs at #2BOF).",
				//				   "Bad TAB #",
				//					MB_ICONHAND | MB_OK);
				//		return false;
				//	}

				//   Tab number control test 3-15-10 k. hubbard
					if ( m_tabNum >= 99999 ) {
						MessageBox("Too many digits. Tab Number must be 5 digits only.",
								   "Bad TAB #",
									MB_ICONHAND | MB_OK);
						return false;
					}		
					
					Answer:

						Valid tab#s for caster 4 is digit 1 = 1, 
							                        digit 2 = 1, 
                                                    digits 3-4 = CSD String# 00-49,
                                                    digit 5 = heat sequence 0-9 (special note: 0=heat sequence#1, 1=heat sequence#2, 2=heat sequence#3, 3=heat sequence#4, etc...)    
                                   for caster 5 is digit 1 = 5,
                                                   digit 2 = 2,
                                                   digits 3-4 CSD String# 50-99,
                                                   digit 5 = heat sequence 0-9 (special note: 0=heat sequence#1, 1=heat sequence#2, 2=heat sequence#3, 3=heat sequence#4, etc...) 											
					Status: we have implemented checks on digits 1,2,3.  4 is not a problem.  Don't know what to do with digit 5
					DONE:

=================================
					
		CCastStringEditorTextController::OnEditMovestringtoothercaster
		
				Can we move strings between casters, involving 4,5?
				
				Answer: Yes we definitely need the ability to move strings between casters involving 4, and 5!
				Status: Nothing to do, so DONE.

==================================
				
	CHeatDetailsDlg::OnValidateCell
		More tab# validation -- what for 4,5
				if ( firstDigit != 9
					 &&
					 ( m_pCasterScen->Caster() == 2 || m_pCasterScen->Caster() == 3 )
					 && 
					 firstDigit != m_pCasterScen->Caster() ) {

					 m_wndDetailsGrid.SetWarningText("First digit of tab# must be 9 or same as caster.");
					 return FALSE;
				}
				if ( m_pCasterScen->Caster() != 1 
					 &&
					 secondDigit != 9 ) {
					m_wndDetailsGrid.SetWarningText("Second digit of tab# must be 9 (for #2BOF).");
					return FALSE;
				}	
				
		Answer: (see tab# logic above to enforce here) 
		Status: DONE.

=============================


	HMLoadGraph -- the hot metal load graph
		DOES THIS NEED TO BE EXTENDED FOR CASTERS 4,5?

	Answer:  Yes please extend for casters 4, and 5

	Status: THis will take a LOT of work.

	New Question: is there more load data for hot metal involving the other plant?


================================